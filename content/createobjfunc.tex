\apisummary{
    Creates an objective function
}

\begin{apidefinition}

\begin{Csynopsis}
    ObjectiveFunction* createObjectiveFunction(Operator *op, void* quantumKernel, int variable_parameters, HeterogeneousMap *options)
\end{Csynopsis}

\begin{Cppsynopsis}
    ObjectiveFunction* qcor::createObjectiveFunction(Operator &op, void &quantumKernel, int variable_parameters, qcor::HeterogeneousMap  &options)
\end{Cppsynopsis}


\begin{apiarguments}
    \apiargument{IN}{op}{Operator defined for measuring the quantum kernel}
    \apiargument{IN}{quantumKernel}{pointer to the quantum kernel}
    \apiargument{IN}{variable\_parameters}{indication of the number of variables in the objective evaluation}
    \apiargument{IN}{options}{a map of string to an arbitrary type for including additional information}
\end{apiarguments}


\apidescription{
        \FUNC{createObjectiveFunction} creates and initializes an instance of \DATATYPENAME{ObjectiveFunction} with a {\em Hermitian} operater, \VAR{op} and quantum kernel, \VAR{quantumKernel}. If a \VAR{op} is not explicitly provided the operator defaults to $Z \otimes Z \cdots \otimes Z$ which results in computational basis measurements. 
  An integer value, \VAR{variable\_parameters} is also passed to \FUNC{createObjectiveFunction} to indicate the number of variable parameters to be evaluated by the objective function.  Additional information may also be provided to the objective function via \VAR{options}. For example, to leverage gradient information, you could specify for \VAR{options} the map \{''gradient``: ''parameter shift``\}, or in the case where you would like to define an additional function to evaluate the output of the operator evaluation, you could specify \VAR{options} to be \{''loss function``:''KL``\}.
}

\apireturnvalues{
    Returns a pointer to a new \DATATYPENAME{ObjectiveFunction}.
}      

\apinotes{
     
}

\end{apidefinition}
