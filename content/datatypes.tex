The \qcor specification has a set of datatypes that enable the expression of quantum concepts within the \qcor \ac{API}s.\\

\subsection{\textbf{ObjectiveFunction}}\label{subsec:ObjectiveFunction}
\DATATYPENAME{ObjectiveFunction} is a representation of a parameterized function y = f(U(x'),x,O)
where x denotes a list of scalar parameters, O denotes an operator, and U(x') denotes a quantum kernel whose behaviour is controlled by x' (related to x as defined by user). \DATATYPENAME{ObjectiveFunction} is initialized with a {\em Hermitian} operater and quantum kernel. As a default the \DATATYPENAME{ObjectiveFunction} evaluates the expectation value of O with respect to U at a given x' (e.g. $<0|U(x')^\dagger \hat{O} U(x')|0>$). \DATATYPENAME{ObjectiveFunction} can be extended to provide specialized processing of the expectation values for non-VQE use cases. Using the default and extended \DATATYPENAME{ObjectiveFunction}, in tandem with the optimizer, one can succinctly implement the variational quantum algorithms, for example VQE.\\  
%default: y = a<Z>(x)+b<ZZ>(x)+... u<ZIIIIIIIZ>(x))
%specialized: y = (log(a<Z>(x))+b<ZZ>(x)+... u<ZIIIIIIIZ>(x)))/log(p(x))... 

\subsection{\textbf{Optimizer}}\label{subsec:Optimizer}
\DATATYPENAME{Optimizer} represents the optmization strategy executed on a given \DATATYPENAME{ObjectiveFunction}. An instance of \DATATYPENAME{Optimizer} may use it's member function, optimize, to evaluate an \DATATYPENAME{ObjectiveFunction} argument to compute the optimal set of parameters which are returned as a \DATATYPENAME{ResultsBuffer}.\\


\subsection{\textbf{ResultsBuffer}}\label{subsec:ResultsBuffer}
\DATATYPENAME{ResultsBuffer} contains the measurement results from a single execution of a quantum-classical task. \DATATYPENAME{ResultsBuffer} are a single \DATATYPENAME{qreg} that contains the optimal results from a task and an ordered list of \DATATYPENAME{qreg} elements that are the intermediate results from the optimization iterations of a task. ResultsBuffer has member functions to access measurements results: \FUNC{getoptresults} returns a pointer to the \DATATYPENAME{qreg} data that contains the optimal results of the quantum-classical task execution; \FUNC{getoptval} returns the optimal double value computed during the quantum-classical task execution; \FUNC{getoptparams} returns the optimal parameters as a vetor of double values that were computed during the quantum-classical task execution; \FUNC{getintermediateresults} returns a pointer to a list of \DATATYPENAME{qreg} elements that contain all results (optimal and sub-optimal) from the quantum-classical task execution.\\

\subsection{\textbf{Handle}}\label{subsec:Handle}
\DATATYPENAME{Handle} is a unique reference to each asynchronously executing quantum-classical task and is generated by a taskInitiate call. \\

\subsection{\textbf{Operator}}\label{subsec:Operator}
% description of how to build/initialize observable should be refined. 
\DATATYPENAME{Operator} is an operator built from Pauli Operators and Field Operators.
% does this refer to the underlying operator transformations?
It contains the data to algebraically relate basic and complex operations, 
% i.e. how we put together the observable from a set of non-commuting measurement bases
%SP 8/4/2020: agree with above comments, could we give an example as well?  Overall this explanation doesn't help me really understand what an observable is.
and the measurements from the observation of the kernel execution.\\
% is a pauli operator a subclass of a observable? consensus? should explicitely state if so. 

%\subsection{\textbf{PauliOperator}}\label{subsec:PauliOperator}
%\DATATYPENAME{PauliOperator} is a single operator type with three attributes: PauliX, PauliY or PauliZ, site/spatial index which is an %integer value, coefficient float value.\\

%\subsection{\textbf{FieldOperator}}\label{subsec:FieldOperator}
%\DATATYPENAME{FieldOperator} is a single operator type with four attributes: creator or anihilator, exchangeStatistics, site/spatial index %(which is an integer value), and a multiplicative complex scalar coefficient.\\

\subsection{\textbf{SiteMap}}\label{subsec:Sitemap}
% is this a mapping between a coodinate system (given a dimensionality) and indicies for the lattice sites? 
\DATATYPENAME{SiteMap} has an integer, \VAR{site\_idx}, and string, \VAR{axis}, attribute. These attributes form a mapping of \VAR{site\_idx} to \VAR{axis} for use in \Clang. \\

\subsection{\textbf{HeterogeneousMap}}\label{subsec:HeterogeneousMap}
\DATATYPENAME{HeterogeneousMap} allows a mapping of a string to an arbitrary type. In \Clang this type is a struct of two attributes, a string \VAR{s} and void pointer \VAR{p}. In \Cpp, this type is analogous to a map and adopts a similar syntax for creating an instance of \DATATYPENAME{HeterogeneousMap} as the \Cpp std::map, but does not require template arguments at declaration. \\

\subsection{\textbf{qreg}}\label{subsec:qreg}
\DATATYPENAME{qreg} is the datatype representation for qubits. \\
